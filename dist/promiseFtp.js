// Generated by CoffeeScript 2.7.0
(function() {
  /* jshint node:true */
  /* jshint -W097 */
  'use strict';
  var FtpClient, FtpConnectionError, FtpReconnectError, Promise, PromiseFtp, STATUSES, complexPassthroughMethods, otherPrototypeMethods, path, simplePassthroughMethods;

  FtpClient = require('@icetee/ftp');

  Promise = require('bluebird');

  path = require('path');

  FtpConnectionError = require('promise-ftp-common').FtpConnectionError;

  FtpReconnectError = require('promise-ftp-common').FtpReconnectError;

  STATUSES = require('promise-ftp-common').STATUSES;

  // these methods need no custom logic; just wrap the common promise, connection-check, and reconnect logic around the
  // originals and pass through any args
  simplePassthroughMethods = ['ascii', 'binary', 'abort', 'delete', 'status', 'rename', 'listSafe', 'list', 'get', 'put', 'append', 'pwd', 'mkdir', 'rmdir', 'system', 'size', 'lastMod', 'restart'];

  // these methods will have custom logic defined, and then will be wrapped in common promise, connection-check, and
  // reconnect logic
  complexPassthroughMethods = ['site', 'cwd', 'cdup'];

  // these methods do not use the common wrapper; they're listed here in order to be properly set on the prototype
  otherPrototypeMethods = ['connect', 'reconnect', 'logout', 'end', 'destroy', 'getConnectionStatus'];

  PromiseFtp = (function() {
    var i, j, len, len1, methodList, methodName, ref;

    class PromiseFtp {
      constructor() {
        var _connect, autoReconnect, autoReconnectPromise, client, closeError, commonLogicFactory, connectOptions, connectionStatus, i, intendedCwd, j, lastError, len, len1, name, preserveCwd, promisifiedClientMethods, unexpectedClose;
        if (!(this instanceof PromiseFtp)) {
          throw new TypeError("PromiseFtp constructor called without 'new' keyword");
        }
        connectionStatus = STATUSES.NOT_YET_CONNECTED;
        client = new FtpClient();
        this.rawClient = client;
        connectOptions = null;
        autoReconnect = null;
        preserveCwd = null;
        intendedCwd = '.';
        lastError = null;
        closeError = null;
        unexpectedClose = null;
        autoReconnectPromise = null;
        promisifiedClientMethods = {};
        
        // always-on event handlers
        client.on('error', function(err) {
          return lastError = err;
        });
        client.on('close', function(hadError) {
          if (hadError) {
            closeError = lastError;
          }
          unexpectedClose = connectionStatus !== STATUSES.DISCONNECTING && connectionStatus !== STATUSES.LOGGING_OUT;
          connectionStatus = STATUSES.DISCONNECTED;
          return autoReconnectPromise = null;
        });
        
        // internal connect logic
        _connect = function(tempStatus) {
          return new Promise(function(resolve, reject) {
            var onError, onReady, serverMessage;
            connectionStatus = tempStatus;
            serverMessage = null;
            client.once('greeting', function(msg) {
              return serverMessage = msg;
            });
            onReady = function() {
              client.removeListener('error', onError);
              connectionStatus = STATUSES.CONNECTED;
              closeError = null;
              unexpectedClose = false;
              return resolve(serverMessage);
            };
            onError = function(err) {
              client.removeListener('ready', onReady);
              return reject(err);
            };
            client.once('ready', onReady);
            client.once('error', onError);
            return client.connect(connectOptions);
          });
        };
        
        // methods listed in otherPrototypeMethods, which don't get a wrapper
        this.connect = function(options) {
          return Promise.try(function() {
            var key, ref, value;
            if (connectionStatus !== STATUSES.NOT_YET_CONNECTED && connectionStatus !== STATUSES.DISCONNECTED) {
              throw new FtpConnectionError(`can't connect when connection status is: '${connectionStatus}'`);
            }
            // copy options object so options can't change without another call to @connect()
            connectOptions = {};
            for (key in options) {
              value = options[key];
              connectOptions[key] = value;
            }
            // deep copy options.secureOptions... or at least mostly, ignoring the possibility of mutable secureOptions fields
            if (options.secureOptions) {
              connectOptions.secureOptions = {};
              ref = options.secureOptions;
              for (key in ref) {
                value = ref[key];
                connectOptions.secureOptions[key] = value;
              }
            }
            // the following options are part of PromiseFtp, so they're not understood by the underlying client
            autoReconnect = !!options.autoReconnect;
            delete connectOptions.autoReconnect;
            preserveCwd = !!options.preserveCwd;
            delete connectOptions.preserveCwd;
            // now that everything is set up, we can connect
            return _connect(STATUSES.CONNECTING);
          });
        };
        this.reconnect = function() {
          return Promise.try(function() {
            if (connectionStatus !== STATUSES.NOT_YET_CONNECTED && connectionStatus !== STATUSES.DISCONNECTED) {
              throw new FtpConnectionError(`can't reconnect when connection status is: '${connectionStatus}'`);
            }
            return _connect(STATUSES.RECONNECTING);
          });
        };
        this.logout = function() {
          var wait;
          wait = autoReconnectPromise ? autoReconnectPromise : Promise.resolve();
          return wait.then(function() {
            if (connectionStatus === STATUSES.NOT_YET_CONNECTED || connectionStatus === STATUSES.DISCONNECTED || connectionStatus === STATUSES.DISCONNECTING) {
              throw new FtpConnectionError(`can't log out when connection status is: ${connectionStatus}`);
            }
            connectionStatus = STATUSES.LOGGING_OUT;
            return promisifiedClientMethods.logout();
          });
        };
        this.end = function() {
          return new Promise(function(resolve, reject) {
            if (connectionStatus === STATUSES.NOT_YET_CONNECTED || connectionStatus === STATUSES.DISCONNECTED) {
              return reject(new FtpConnectionError(`can't end connection when connection status is: ${connectionStatus}`));
            }
            connectionStatus = STATUSES.DISCONNECTING;
            client.once('close', function(hadError) {
              return resolve(hadError ? lastError || true : false);
            });
            return client.end();
          });
        };
        this.destroy = function() {
          var wasDisconnected;
          if (connectionStatus === STATUSES.NOT_YET_CONNECTED || connectionStatus === STATUSES.DISCONNECTED) {
            wasDisconnected = true;
          } else {
            wasDisconnected = false;
            connectionStatus = STATUSES.DISCONNECTING;
          }
          client.destroy();
          return wasDisconnected;
        };
        this.getConnectionStatus = function() {
          return connectionStatus;
        };
        
        // methods listed in complexPassthroughMethods, which will get a common logic wrapper
        this.site = function(command) {
          return promisifiedClientMethods.site(command).then(function(result) {
            return {
              text: result[0],
              code: result[1]
            };
          });
        };
        this.cwd = function(dir) {
          return promisifiedClientMethods.cwd(dir).then(function(result) {
            if (dir.charAt(0) === '/') {
              intendedCwd = path.normalize(dir);
            } else {
              intendedCwd = path.join(intendedCwd, dir);
            }
            return result;
          });
        };
        this.cdup = function() {
          return promisifiedClientMethods.cdup().then(function(result) {
            intendedCwd = path.join(intendedCwd, '..');
            return result;
          });
        };
        
        // common promise, connection-check, and reconnect logic
        commonLogicFactory = function(name, handler) {
          promisifiedClientMethods[name] = function(...args) {
            return new Promise(function(resolve, reject) {
              var onError;
              onError = function(err) {
                return reject(err);
              };
              client.once('error', onError);
              return client[name](...args, function(err, res) {
                client.removeListener('error', onError);
                if (err) {
                  return reject(err);
                } else {
                  return resolve(res);
                }
              });
            });
          };
          if (!handler) {
            handler = promisifiedClientMethods[name];
          }
          return function(...args) {
            return Promise.try(() => {
              // if we need to reconnect and we're not already reconnecting, start reconnect
              if (unexpectedClose && autoReconnect && !autoReconnectPromise) {
                autoReconnectPromise = _connect(STATUSES.RECONNECTING).catch(function(err) {
                  throw new FtpReconnectError(closeError, err, false);
                }).then(function() {
                  if (preserveCwd) {
                    return promisifiedClientMethods.cwd(intendedCwd).catch((err) => {
                      this.destroy();
                      throw new FtpReconnectError(closeError, err, true);
                    });
                  } else {
                    return intendedCwd = '.';
                  }
                });
              }
              // if we just started reconnecting or were already reconnecting, wait for that to finish before continuing
              if (autoReconnectPromise) {
                return autoReconnectPromise;
              } else if (connectionStatus !== STATUSES.CONNECTED) {
                throw new FtpConnectionError(`can't perform '${name}' command when connection status is: ${connectionStatus}`);
              }
            }).then(function() {
              // now perform the requested command
              return handler(...args);
            });
          };
        };
// create the methods listed in simplePassthroughMethods as common logic wrapped around the original client method
        for (i = 0, len = simplePassthroughMethods.length; i < len; i++) {
          name = simplePassthroughMethods[i];
          this[name] = commonLogicFactory(name);
        }
// wrap the methods listed in complexPassthroughMethods with common logic
        for (j = 0, len1 = complexPassthroughMethods.length; j < len1; j++) {
          name = complexPassthroughMethods[j];
          this[name] = commonLogicFactory(name, this[name]);
        }
      }

    };

    ref = [simplePassthroughMethods, complexPassthroughMethods, otherPrototypeMethods];
    
    // set method names on the prototype; they'll be overwritten with real functions from inside the constructor's closure
    for (i = 0, len = ref.length; i < len; i++) {
      methodList = ref[i];
      for (j = 0, len1 = methodList.length; j < len1; j++) {
        methodName = methodList[j];
        PromiseFtp.prototype[methodName] = null;
      }
    }

    return PromiseFtp;

  }).call(this);

  module.exports = PromiseFtp;

}).call(this);
